"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = void 0;
/* eslint-disable no-fallthrough */
const error_1 = require("../error");
const scopes_1 = require("../auth/scopes");
const propertiesToSave = [
    'id',
    'shop',
    'state',
    'isOnline',
    'scope',
    'accessToken',
    'expires',
    'onlineAccessInfo',
];
/**
 * Stores App information from logged in merchants so they can make authenticated requests to the Admin API.
 */
class Session {
    static fromPropertyArray(entries, returnUserData = false) {
        if (!Array.isArray(entries)) {
            throw new error_1.InvalidSession('The parameter is not an array: a Session cannot be created from this object.');
        }
        const associatedUserObj = {
            associated_user: {},
        };
        const obj = Object.fromEntries(entries
            .filter(([_key, value]) => value !== null && value !== undefined)
            // Sanitize keys
            .map(([key, value]) => {
            switch (key.toLowerCase()) {
                case 'isonline':
                    return ['isOnline', value];
                case 'accesstoken':
                    return ['accessToken', value];
                case 'onlineaccessinfo':
                    return ['onlineAccessInfo', value];
                case 'userid':
                    return ['userId', value];
                case 'firstname':
                    return ['firstName', value];
                case 'lastname':
                    return ['lastName', value];
                case 'accountowner':
                    return ['accountOwner', value];
                case 'emailverified':
                    return ['emailVerified', value];
                default:
                    return [key.toLowerCase(), value];
            }
        })
            // Sanitize values
            .map(([key, value]) => {
            switch (key) {
                case 'isOnline':
                    if (typeof value === 'string') {
                        return [key, value.toString().toLowerCase() === 'true'];
                    }
                    else if (typeof value === 'number') {
                        return [key, Boolean(value)];
                    }
                    return [key, value];
                case 'scope':
                    return [key, value.toString()];
                case 'expires':
                    return [key, value ? new Date(Number(value)) : undefined];
                case 'onlineAccessInfo':
                    return [
                        key,
                        {
                            associated_user: {
                                id: Number(value),
                            },
                        },
                    ];
                case 'userId':
                    if (returnUserData) {
                        return [
                            key,
                            (associatedUserObj.associated_user.id = Number(value)),
                        ];
                    }
                case 'firstName':
                    if (returnUserData) {
                        return [
                            key,
                            (associatedUserObj.associated_user.first_name =
                                String(value)),
                        ];
                    }
                case 'lastName':
                    if (returnUserData) {
                        return [
                            key,
                            (associatedUserObj.associated_user.last_name = String(value)),
                        ];
                    }
                case 'email':
                    if (returnUserData) {
                        return [
                            key,
                            (associatedUserObj.associated_user.email = String(value)),
                        ];
                    }
                case 'accountOwner':
                    if (returnUserData) {
                        return [
                            key,
                            (associatedUserObj.associated_user.account_owner =
                                Boolean(value)),
                        ];
                    }
                case 'locale':
                    if (returnUserData) {
                        return [
                            key,
                            (associatedUserObj.associated_user.locale = String(value)),
                        ];
                    }
                case 'collaborator':
                    if (returnUserData) {
                        return [
                            key,
                            (associatedUserObj.associated_user.collaborator =
                                Boolean(value)),
                        ];
                    }
                case 'emailVerified':
                    if (returnUserData) {
                        return [
                            key,
                            (associatedUserObj.associated_user.email_verified =
                                Boolean(value)),
                        ];
                    }
                // If returnUserData is false, return any user keys as passed in
                default:
                    return [key, value];
            }
        }));
        // If the onlineAccessInfo is not present, we are using the new session info and  add it to the object
        if (returnUserData) {
            obj.onlineAccessInfo = associatedUserObj;
        }
        Object.setPrototypeOf(obj, Session.prototype);
        return obj;
    }
    constructor(params) {
        Object.assign(this, params);
    }
    /**
     * Whether the session is active. Active sessions have an access token that is not expired, and has the given scopes.
     */
    isActive(scopes) {
        return (!this.isScopeChanged(scopes) &&
            Boolean(this.accessToken) &&
            !this.isExpired());
    }
    /**
     * Whether the access token has the given scopes.
     */
    isScopeChanged(scopes) {
        const scopesObject = scopes instanceof scopes_1.AuthScopes ? scopes : new scopes_1.AuthScopes(scopes);
        return !scopesObject.equals(this.scope);
    }
    /**
     * Whether the access token is expired.
     */
    isExpired(withinMillisecondsOfExpiry = 0) {
        return Boolean(this.expires &&
            this.expires.getTime() - withinMillisecondsOfExpiry < Date.now());
    }
    /**
     * Converts an object with data into a Session.
     */
    toObject() {
        const object = {
            id: this.id,
            shop: this.shop,
            state: this.state,
            isOnline: this.isOnline,
        };
        if (this.scope) {
            object.scope = this.scope;
        }
        if (this.expires) {
            object.expires = this.expires;
        }
        if (this.accessToken) {
            object.accessToken = this.accessToken;
        }
        if (this.onlineAccessInfo) {
            object.onlineAccessInfo = this.onlineAccessInfo;
        }
        return object;
    }
    /**
     * Checks whether the given session is equal to this session.
     */
    equals(other) {
        if (!other)
            return false;
        const mandatoryPropsMatch = this.id === other.id &&
            this.shop === other.shop &&
            this.state === other.state &&
            this.isOnline === other.isOnline;
        if (!mandatoryPropsMatch)
            return false;
        const copyA = this.toPropertyArray(true);
        copyA.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));
        const copyB = other.toPropertyArray(true);
        copyB.sort(([k1], [k2]) => (k1 < k2 ? -1 : 1));
        return JSON.stringify(copyA) === JSON.stringify(copyB);
    }
    /**
     * Converts the session into an array of key-value pairs.
     */
    toPropertyArray(returnUserData = false) {
        return (Object.entries(this)
            .filter(([key, value]) => propertiesToSave.includes(key) &&
            value !== undefined &&
            value !== null)
            // Prepare values for db storage
            .flatMap(([key, value]) => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            switch (key) {
                case 'expires':
                    return [[key, value ? value.getTime() : undefined]];
                case 'onlineAccessInfo':
                    // eslint-disable-next-line no-negated-condition
                    if (!returnUserData) {
                        return [[key, value.associated_user.id]];
                    }
                    else {
                        return [
                            ['userId', (_a = value === null || value === void 0 ? void 0 : value.associated_user) === null || _a === void 0 ? void 0 : _a.id],
                            ['firstName', (_b = value === null || value === void 0 ? void 0 : value.associated_user) === null || _b === void 0 ? void 0 : _b.first_name],
                            ['lastName', (_c = value === null || value === void 0 ? void 0 : value.associated_user) === null || _c === void 0 ? void 0 : _c.last_name],
                            ['email', (_d = value === null || value === void 0 ? void 0 : value.associated_user) === null || _d === void 0 ? void 0 : _d.email],
                            ['locale', (_e = value === null || value === void 0 ? void 0 : value.associated_user) === null || _e === void 0 ? void 0 : _e.locale],
                            ['emailVerified', (_f = value === null || value === void 0 ? void 0 : value.associated_user) === null || _f === void 0 ? void 0 : _f.email_verified],
                            ['accountOwner', (_g = value === null || value === void 0 ? void 0 : value.associated_user) === null || _g === void 0 ? void 0 : _g.account_owner],
                            ['collaborator', (_h = value === null || value === void 0 ? void 0 : value.associated_user) === null || _h === void 0 ? void 0 : _h.collaborator],
                        ];
                    }
                default:
                    return [[key, value]];
            }
        })
            // Filter out tuples with undefined values
            .filter(([_key, value]) => value !== undefined));
    }
}
exports.Session = Session;
//# sourceMappingURL=session.js.map