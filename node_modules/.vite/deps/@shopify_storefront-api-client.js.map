{
  "version": 3,
  "sources": ["../../@shopify/graphql-client/dist/graphql-client/constants.mjs", "../../@shopify/graphql-client/dist/graphql-client/utilities.mjs", "../../@shopify/graphql-client/dist/graphql-client/http-fetch.mjs", "../../@shopify/graphql-client/dist/graphql-client/graphql-client.mjs", "../../@shopify/graphql-client/dist/api-client-utilities/validations.mjs", "../../@shopify/graphql-client/dist/api-client-utilities/api-versions.mjs", "../../@shopify/graphql-client/dist/api-client-utilities/utilities.mjs", "../../@shopify/src/constants.ts", "../../@shopify/src/validations.ts", "../../@shopify/src/storefront-api-client.ts"],
  "sourcesContent": ["const CLIENT = \"GraphQL Client\";\nconst MIN_RETRIES = 0;\nconst MAX_RETRIES = 3;\nconst GQL_API_ERROR = \"An error occurred while fetching from the API. Review 'graphQLErrors' for details.\";\nconst UNEXPECTED_CONTENT_TYPE_ERROR = \"Response returned unexpected Content-Type:\";\nconst NO_DATA_OR_ERRORS_ERROR = \"An unknown error has occurred. The API did not return a data object or any errors in its response.\";\nconst CONTENT_TYPES = {\n    json: \"application/json\",\n    multipart: \"multipart/mixed\",\n};\nconst SDK_VARIANT_HEADER = \"X-SDK-Variant\";\nconst SDK_VERSION_HEADER = \"X-SDK-Version\";\nconst DEFAULT_SDK_VARIANT = \"shopify-graphql-client\";\n// This is value is replaced with package.json version during rollup build process\nconst DEFAULT_CLIENT_VERSION = \"0.10.3\";\nconst RETRY_WAIT_TIME = 1000;\nconst RETRIABLE_STATUS_CODES = [429, 503];\nconst DEFER_OPERATION_REGEX = /@(defer)\\b/i;\nconst NEWLINE_SEPARATOR = \"\\r\\n\";\nconst BOUNDARY_HEADER_REGEX = /boundary=\"?([^=\";]+)\"?/i;\nconst HEADER_SEPARATOR = NEWLINE_SEPARATOR + NEWLINE_SEPARATOR;\n\nexport { BOUNDARY_HEADER_REGEX, CLIENT, CONTENT_TYPES, DEFAULT_CLIENT_VERSION, DEFAULT_SDK_VARIANT, DEFER_OPERATION_REGEX, GQL_API_ERROR, HEADER_SEPARATOR, MAX_RETRIES, MIN_RETRIES, NEWLINE_SEPARATOR, NO_DATA_OR_ERRORS_ERROR, RETRIABLE_STATUS_CODES, RETRY_WAIT_TIME, SDK_VARIANT_HEADER, SDK_VERSION_HEADER, UNEXPECTED_CONTENT_TYPE_ERROR };\n//# sourceMappingURL=constants.mjs.map\n", "import { MIN_RETRIES, MAX_RETRIES, CLIENT } from './constants.mjs';\n\nfunction formatErrorMessage(message, client = CLIENT) {\n    return message.startsWith(`${client}`) ? message : `${client}: ${message}`;\n}\nfunction getErrorMessage(error) {\n    return error instanceof Error ? error.message : JSON.stringify(error);\n}\nfunction getErrorCause(error) {\n    return error instanceof Error && error.cause ? error.cause : undefined;\n}\nfunction combineErrors(dataArray) {\n    return dataArray.flatMap(({ errors }) => {\n        return errors ?? [];\n    });\n}\nfunction validateRetries({ client, retries, }) {\n    if (retries !== undefined &&\n        (typeof retries !== \"number\" ||\n            retries < MIN_RETRIES ||\n            retries > MAX_RETRIES)) {\n        throw new Error(`${client}: The provided \"retries\" value (${retries}) is invalid - it cannot be less than ${MIN_RETRIES} or greater than ${MAX_RETRIES}`);\n    }\n}\nfunction getKeyValueIfValid(key, value) {\n    return value &&\n        (typeof value !== \"object\" ||\n            Array.isArray(value) ||\n            (typeof value === \"object\" && Object.keys(value).length > 0))\n        ? { [key]: value }\n        : {};\n}\nfunction buildDataObjectByPath(path, data) {\n    if (path.length === 0) {\n        return data;\n    }\n    const key = path.pop();\n    const newData = {\n        [key]: data,\n    };\n    if (path.length === 0) {\n        return newData;\n    }\n    return buildDataObjectByPath(path, newData);\n}\nfunction combineObjects(baseObject, newObject) {\n    return Object.keys(newObject || {}).reduce((acc, key) => {\n        if ((typeof newObject[key] === \"object\" || Array.isArray(newObject[key])) &&\n            baseObject[key]) {\n            acc[key] = combineObjects(baseObject[key], newObject[key]);\n            return acc;\n        }\n        acc[key] = newObject[key];\n        return acc;\n    }, Array.isArray(baseObject) ? [...baseObject] : { ...baseObject });\n}\nfunction buildCombinedDataObject([initialDatum, ...remainingData]) {\n    return remainingData.reduce(combineObjects, { ...initialDatum });\n}\n\nexport { buildCombinedDataObject, buildDataObjectByPath, combineErrors, formatErrorMessage, getErrorCause, getErrorMessage, getKeyValueIfValid, validateRetries };\n//# sourceMappingURL=utilities.mjs.map\n", "import { CLIENT, RETRY_WAIT_TIME, RETRIABLE_STATUS_CODES } from './constants.mjs';\nimport { formatErrorMessage, getErrorMessage } from './utilities.mjs';\n\nfunction generateHttpFetch({ clientLogger, customFetchApi = fetch, client = CLIENT, defaultRetryWaitTime = RETRY_WAIT_TIME, retriableCodes = RETRIABLE_STATUS_CODES, }) {\n    const httpFetch = async (requestParams, count, maxRetries) => {\n        const nextCount = count + 1;\n        const maxTries = maxRetries + 1;\n        let response;\n        try {\n            response = await customFetchApi(...requestParams);\n            clientLogger({\n                type: \"HTTP-Response\",\n                content: {\n                    requestParams,\n                    response,\n                },\n            });\n            if (!response.ok &&\n                retriableCodes.includes(response.status) &&\n                nextCount <= maxTries) {\n                throw new Error();\n            }\n            return response;\n        }\n        catch (error) {\n            if (nextCount <= maxTries) {\n                const retryAfter = response?.headers.get(\"Retry-After\");\n                await sleep(retryAfter ? parseInt(retryAfter, 10) : defaultRetryWaitTime);\n                clientLogger({\n                    type: \"HTTP-Retry\",\n                    content: {\n                        requestParams,\n                        lastResponse: response,\n                        retryAttempt: count,\n                        maxRetries,\n                    },\n                });\n                return httpFetch(requestParams, nextCount, maxRetries);\n            }\n            throw new Error(formatErrorMessage(`${maxRetries > 0\n                ? `Attempted maximum number of ${maxRetries} network retries. Last message - `\n                : \"\"}${getErrorMessage(error)}`, client));\n        }\n    };\n    return httpFetch;\n}\nasync function sleep(waitTime) {\n    return new Promise((resolve) => setTimeout(resolve, waitTime));\n}\n\nexport { generateHttpFetch };\n//# sourceMappingURL=http-fetch.mjs.map\n", "import { generateHttpFetch } from './http-fetch.mjs';\nimport { CLIENT, SDK_VARIANT_HEADER, SDK_VERSION_HEADER, DEFAULT_SDK_VARIANT, DEFAULT_CLIENT_VERSION, DEFER_OPERATION_REGEX, CONTENT_TYPES, UNEXPECTED_CONTENT_TYPE_ERROR, GQL_API_ERROR, NO_DATA_OR_ERRORS_ERROR, BOUNDARY_HEADER_REGEX, RETRY_WAIT_TIME, HEADER_SEPARATOR } from './constants.mjs';\nimport { validateRetries, formatErrorMessage, getErrorMessage, getErrorCause, getKeyValueIfValid, combineErrors, buildCombinedDataObject, buildDataObjectByPath } from './utilities.mjs';\n\nfunction createGraphQLClient({ headers, url, customFetchApi = fetch, retries = 0, logger, }) {\n    validateRetries({ client: CLIENT, retries });\n    const config = {\n        headers,\n        url,\n        retries,\n    };\n    const clientLogger = generateClientLogger(logger);\n    const httpFetch = generateHttpFetch({\n        customFetchApi,\n        clientLogger,\n        defaultRetryWaitTime: RETRY_WAIT_TIME,\n    });\n    const fetch = generateFetch(httpFetch, config);\n    const request = generateRequest(fetch);\n    const requestStream = generateRequestStream(fetch);\n    return {\n        config,\n        fetch,\n        request,\n        requestStream,\n    };\n}\nfunction generateClientLogger(logger) {\n    return (logContent) => {\n        if (logger) {\n            logger(logContent);\n        }\n    };\n}\nasync function processJSONResponse(response) {\n    const { errors, data, extensions } = await response.json();\n    return {\n        ...getKeyValueIfValid(\"data\", data),\n        ...getKeyValueIfValid(\"extensions\", extensions),\n        ...(errors || !data\n            ? {\n                errors: {\n                    networkStatusCode: response.status,\n                    message: formatErrorMessage(errors ? GQL_API_ERROR : NO_DATA_OR_ERRORS_ERROR),\n                    ...getKeyValueIfValid(\"graphQLErrors\", errors),\n                    response,\n                },\n            }\n            : {}),\n    };\n}\nfunction generateFetch(httpFetch, { url, headers, retries }) {\n    return async (operation, options = {}) => {\n        const { variables, headers: overrideHeaders, url: overrideUrl, retries: overrideRetries, } = options;\n        const body = JSON.stringify({\n            query: operation,\n            variables,\n        });\n        validateRetries({ client: CLIENT, retries: overrideRetries });\n        const flatHeaders = Object.entries({\n            ...headers,\n            ...overrideHeaders,\n        }).reduce((headers, [key, value]) => {\n            headers[key] = Array.isArray(value) ? value.join(\", \") : value.toString();\n            return headers;\n        }, {});\n        if (!flatHeaders[SDK_VARIANT_HEADER] && !flatHeaders[SDK_VERSION_HEADER]) {\n            flatHeaders[SDK_VARIANT_HEADER] = DEFAULT_SDK_VARIANT;\n            flatHeaders[SDK_VERSION_HEADER] = DEFAULT_CLIENT_VERSION;\n        }\n        const fetchParams = [\n            overrideUrl ?? url,\n            {\n                method: \"POST\",\n                headers: flatHeaders,\n                body,\n            },\n        ];\n        return httpFetch(fetchParams, 1, overrideRetries ?? retries);\n    };\n}\nfunction generateRequest(fetch) {\n    return async (...props) => {\n        if (DEFER_OPERATION_REGEX.test(props[0])) {\n            throw new Error(formatErrorMessage(\"This operation will result in a streamable response - use requestStream() instead.\"));\n        }\n        try {\n            const response = await fetch(...props);\n            const { status, statusText } = response;\n            const contentType = response.headers.get(\"content-type\") || \"\";\n            if (!response.ok) {\n                return {\n                    errors: {\n                        networkStatusCode: status,\n                        message: formatErrorMessage(statusText),\n                        response,\n                    },\n                };\n            }\n            if (!contentType.includes(CONTENT_TYPES.json)) {\n                return {\n                    errors: {\n                        networkStatusCode: status,\n                        message: formatErrorMessage(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${contentType}`),\n                        response,\n                    },\n                };\n            }\n            return processJSONResponse(response);\n        }\n        catch (error) {\n            return {\n                errors: {\n                    message: getErrorMessage(error),\n                },\n            };\n        }\n    };\n}\nasync function* getStreamBodyIterator(response) {\n    const decoder = new TextDecoder();\n    // Response body is an async iterator\n    if (response.body[Symbol.asyncIterator]) {\n        for await (const chunk of response.body) {\n            yield decoder.decode(chunk);\n        }\n    }\n    else {\n        const reader = response.body.getReader();\n        let readResult;\n        try {\n            while (!(readResult = await reader.read()).done) {\n                yield decoder.decode(readResult.value);\n            }\n        }\n        finally {\n            reader.cancel();\n        }\n    }\n}\nfunction readStreamChunk(streamBodyIterator, boundary) {\n    return {\n        async *[Symbol.asyncIterator]() {\n            try {\n                let buffer = \"\";\n                for await (const textChunk of streamBodyIterator) {\n                    buffer += textChunk;\n                    if (buffer.indexOf(boundary) > -1) {\n                        const lastBoundaryIndex = buffer.lastIndexOf(boundary);\n                        const fullResponses = buffer.slice(0, lastBoundaryIndex);\n                        const chunkBodies = fullResponses\n                            .split(boundary)\n                            .filter((chunk) => chunk.trim().length > 0)\n                            .map((chunk) => {\n                            const body = chunk\n                                .slice(chunk.indexOf(HEADER_SEPARATOR) + HEADER_SEPARATOR.length)\n                                .trim();\n                            return body;\n                        });\n                        if (chunkBodies.length > 0) {\n                            yield chunkBodies;\n                        }\n                        buffer = buffer.slice(lastBoundaryIndex + boundary.length);\n                        if (buffer.trim() === `--`) {\n                            buffer = \"\";\n                        }\n                    }\n                }\n            }\n            catch (error) {\n                throw new Error(`Error occured while processing stream payload - ${getErrorMessage(error)}`);\n            }\n        },\n    };\n}\nfunction createJsonResponseAsyncIterator(response) {\n    return {\n        async *[Symbol.asyncIterator]() {\n            const processedResponse = await processJSONResponse(response);\n            yield {\n                ...processedResponse,\n                hasNext: false,\n            };\n        },\n    };\n}\nfunction getResponseDataFromChunkBodies(chunkBodies) {\n    return chunkBodies\n        .map((value) => {\n        try {\n            return JSON.parse(value);\n        }\n        catch (error) {\n            throw new Error(`Error in parsing multipart response - ${getErrorMessage(error)}`);\n        }\n    })\n        .map((payload) => {\n        const { data, incremental, hasNext, extensions, errors } = payload;\n        // initial data chunk\n        if (!incremental) {\n            return {\n                data: data || {},\n                ...getKeyValueIfValid(\"errors\", errors),\n                ...getKeyValueIfValid(\"extensions\", extensions),\n                hasNext,\n            };\n        }\n        // subsequent data chunks\n        const incrementalArray = incremental.map(({ data, path, errors }) => {\n            return {\n                data: data && path ? buildDataObjectByPath(path, data) : {},\n                ...getKeyValueIfValid(\"errors\", errors),\n            };\n        });\n        return {\n            data: incrementalArray.length === 1\n                ? incrementalArray[0].data\n                : buildCombinedDataObject([\n                    ...incrementalArray.map(({ data }) => data),\n                ]),\n            ...getKeyValueIfValid(\"errors\", combineErrors(incrementalArray)),\n            hasNext,\n        };\n    });\n}\nfunction validateResponseData(responseErrors, combinedData) {\n    if (responseErrors.length > 0) {\n        throw new Error(GQL_API_ERROR, {\n            cause: {\n                graphQLErrors: responseErrors,\n            },\n        });\n    }\n    if (Object.keys(combinedData).length === 0) {\n        throw new Error(NO_DATA_OR_ERRORS_ERROR);\n    }\n}\nfunction createMultipartResponseAsyncInterator(response, responseContentType) {\n    const boundaryHeader = (responseContentType ?? \"\").match(BOUNDARY_HEADER_REGEX);\n    const boundary = `--${boundaryHeader ? boundaryHeader[1] : \"-\"}`;\n    if (!response.body?.getReader &&\n        !response.body[Symbol.asyncIterator]) {\n        throw new Error(\"API multipart response did not return an iterable body\", {\n            cause: response,\n        });\n    }\n    const streamBodyIterator = getStreamBodyIterator(response);\n    let combinedData = {};\n    let responseExtensions;\n    return {\n        async *[Symbol.asyncIterator]() {\n            try {\n                let streamHasNext = true;\n                for await (const chunkBodies of readStreamChunk(streamBodyIterator, boundary)) {\n                    const responseData = getResponseDataFromChunkBodies(chunkBodies);\n                    responseExtensions =\n                        responseData.find((datum) => datum.extensions)?.extensions ??\n                            responseExtensions;\n                    const responseErrors = combineErrors(responseData);\n                    combinedData = buildCombinedDataObject([\n                        combinedData,\n                        ...responseData.map(({ data }) => data),\n                    ]);\n                    streamHasNext = responseData.slice(-1)[0].hasNext;\n                    validateResponseData(responseErrors, combinedData);\n                    yield {\n                        ...getKeyValueIfValid(\"data\", combinedData),\n                        ...getKeyValueIfValid(\"extensions\", responseExtensions),\n                        hasNext: streamHasNext,\n                    };\n                }\n                if (streamHasNext) {\n                    throw new Error(`Response stream terminated unexpectedly`);\n                }\n            }\n            catch (error) {\n                const cause = getErrorCause(error);\n                yield {\n                    ...getKeyValueIfValid(\"data\", combinedData),\n                    ...getKeyValueIfValid(\"extensions\", responseExtensions),\n                    errors: {\n                        message: formatErrorMessage(getErrorMessage(error)),\n                        networkStatusCode: response.status,\n                        ...getKeyValueIfValid(\"graphQLErrors\", cause?.graphQLErrors),\n                        response,\n                    },\n                    hasNext: false,\n                };\n            }\n        },\n    };\n}\nfunction generateRequestStream(fetch) {\n    return async (...props) => {\n        if (!DEFER_OPERATION_REGEX.test(props[0])) {\n            throw new Error(formatErrorMessage(\"This operation does not result in a streamable response - use request() instead.\"));\n        }\n        try {\n            const response = await fetch(...props);\n            const { statusText } = response;\n            if (!response.ok) {\n                throw new Error(statusText, { cause: response });\n            }\n            const responseContentType = response.headers.get(\"content-type\") || \"\";\n            switch (true) {\n                case responseContentType.includes(CONTENT_TYPES.json):\n                    return createJsonResponseAsyncIterator(response);\n                case responseContentType.includes(CONTENT_TYPES.multipart):\n                    return createMultipartResponseAsyncInterator(response, responseContentType);\n                default:\n                    throw new Error(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${responseContentType}`, { cause: response });\n            }\n        }\n        catch (error) {\n            return {\n                async *[Symbol.asyncIterator]() {\n                    const response = getErrorCause(error);\n                    yield {\n                        errors: {\n                            message: formatErrorMessage(getErrorMessage(error)),\n                            ...getKeyValueIfValid(\"networkStatusCode\", response?.status),\n                            ...getKeyValueIfValid(\"response\", response),\n                        },\n                        hasNext: false,\n                    };\n                },\n            };\n        }\n    };\n}\n\nexport { createGraphQLClient, generateClientLogger };\n//# sourceMappingURL=graphql-client.mjs.map\n", "function validateDomainAndGetStoreUrl({ client, storeDomain, }) {\n    try {\n        if (!storeDomain || typeof storeDomain !== \"string\") {\n            throw new Error();\n        }\n        const trimmedDomain = storeDomain.trim();\n        const protocolUrl = trimmedDomain.match(/^https?:/)\n            ? trimmedDomain\n            : `https://${trimmedDomain}`;\n        const url = new URL(protocolUrl);\n        url.protocol = \"https\";\n        return url.origin;\n    }\n    catch (_error) {\n        throw new Error(`${client}: a valid store domain (\"${storeDomain}\") must be provided`);\n    }\n}\nfunction validateApiVersion({ client, currentSupportedApiVersions, apiVersion, logger, }) {\n    const versionError = `${client}: the provided apiVersion (\"${apiVersion}\")`;\n    const supportedVersion = `Currently supported API versions: ${currentSupportedApiVersions.join(\", \")}`;\n    if (!apiVersion || typeof apiVersion !== \"string\") {\n        throw new Error(`${versionError} is invalid. ${supportedVersion}`);\n    }\n    const trimmedApiVersion = apiVersion.trim();\n    if (!currentSupportedApiVersions.includes(trimmedApiVersion)) {\n        if (logger) {\n            logger({\n                type: \"Unsupported_Api_Version\",\n                content: {\n                    apiVersion,\n                    supportedApiVersions: currentSupportedApiVersions,\n                },\n            });\n        }\n        else {\n            console.warn(`${versionError} is likely deprecated or not supported. ${supportedVersion}`);\n        }\n    }\n}\n\nexport { validateApiVersion, validateDomainAndGetStoreUrl };\n//# sourceMappingURL=validations.mjs.map\n", "function getQuarterMonth(quarter) {\n    const month = quarter * 3 - 2;\n    return month === 10 ? month : `0${month}`;\n}\nfunction getPrevousVersion(year, quarter, nQuarter) {\n    const versionQuarter = quarter - nQuarter;\n    if (versionQuarter <= 0) {\n        return `${year - 1}-${getQuarterMonth(versionQuarter + 4)}`;\n    }\n    return `${year}-${getQuarterMonth(versionQuarter)}`;\n}\nfunction getCurrentApiVersion() {\n    const date = new Date();\n    const month = date.getUTCMonth();\n    const year = date.getUTCFullYear();\n    const quarter = Math.floor(month / 3 + 1);\n    return {\n        year,\n        quarter,\n        version: `${year}-${getQuarterMonth(quarter)}`,\n    };\n}\nfunction getCurrentSupportedApiVersions() {\n    const { year, quarter, version: currentVersion } = getCurrentApiVersion();\n    const nextVersion = quarter === 4\n        ? `${year + 1}-01`\n        : `${year}-${getQuarterMonth(quarter + 1)}`;\n    return [\n        getPrevousVersion(year, quarter, 3),\n        getPrevousVersion(year, quarter, 2),\n        getPrevousVersion(year, quarter, 1),\n        currentVersion,\n        nextVersion,\n        \"unstable\",\n    ];\n}\n\nexport { getCurrentApiVersion, getCurrentSupportedApiVersions };\n//# sourceMappingURL=api-versions.mjs.map\n", "function generateGetHeaders(config) {\n    return (customHeaders) => {\n        return { ...(customHeaders ?? {}), ...config.headers };\n    };\n}\nfunction generateGetGQLClientParams({ getHeaders, getApiUrl }) {\n    return (operation, options) => {\n        const props = [operation];\n        if (options && Object.keys(options).length > 0) {\n            const { variables, apiVersion: propApiVersion, headers, retries, } = options;\n            props.push({\n                ...(variables ? { variables } : {}),\n                ...(headers ? { headers: getHeaders(headers) } : {}),\n                ...(propApiVersion ? { url: getApiUrl(propApiVersion) } : {}),\n                ...(retries ? { retries } : {}),\n            });\n        }\n        return props;\n    };\n}\n\nexport { generateGetGQLClientParams, generateGetHeaders };\n//# sourceMappingURL=utilities.mjs.map\n", null, null, null],
  "mappings": "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",
  "names": ["fetch", "headers", "data", "errors", "_a", "DEFAULT_SDK_VARIANT", "DEFAULT_CLIENT_VERSION", "SDK_VARIANT_HEADER", "SDK_VERSION_HEADER", "CLIENT", "CLIENT", "CLIENT", "SDK_VARIANT_HEADER", "DEFAULT_SDK_VARIANT", "SDK_VERSION_HEADER", "DEFAULT_CLIENT_VERSION"]
}
